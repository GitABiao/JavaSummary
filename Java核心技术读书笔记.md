# Java基础知识
## Java基本程序设计结构
### 数据类型
### 大数值
### 变量
### 运算符
### 字符串
### 输入输出
### 控制流
### 数组
****
## 对象与类
### 面向对象概述
### 预定义类
### 自定义类
### 静态域与静态方法
### 方法参数
### 对象构造
### 包
### 类路径
### 类设计技巧
****
## 继承
### 接口
### 对象克隆
### 接口与回调
### 内部类
### 代理
****
## 异常、断言、日志和调试
### 处理错误
### 捕获异常
### 使用异常机制的技巧
### 使用断言
### 记录日志
### 调试技巧
### 使用调试器
****
## 泛型
****
## 集合
### 集合接口
### 具体的集合
### 集合框架
### 算法
### 遗留的集合
****
## 多线程[(深入理解)](https://github.com/GitABiao/AndroidSummary/blob/master/Primary/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B.md)
### 线程概念
  一个程序同时执行多个任务，通常每一个任务称为一个线程，它是线程控制的简称。  
  * 线程与进程本质的区别是：进程拥有自己的一套变量，而线程则共享数据。

### 中断线程
  >由于没有**强制**中断现成的方法，所以只能使用interrupt方法来**请求**终止线程。当一个线程调用interrupt方法是，该现成的**中断状态**将被置位。这时可以通过调用isInterrupt方法来判断线程是否被终止。当在一个被阻塞的线程上调用interrupt方法时，将无法检测isInterrupt状态，阻塞线程将会被产生的**InterruptedExceprion**异常终止。  
  线程中断不强制终止，只是告知并引起它的注意。

### 线程状态(六种)
1. New(新建)
  >使用new关键字创建一个线程时，线程还没开始运行。

2. Runnable(可运行)
  >调用start()方法之后线程处于可运行状态。这是可能处于运行状态，也可能没有运行，这取决于操作系统提供给线程的运行时间。  
      在单核处理器或者处理器数量小于线程数时，线程的运行主要分为**抢占式调度**和**协作式调度**。处理器数量大于等于线程数时，每个处理器运行一个线程。

3. Blocked(阻塞)
  >当线程试图访问一个内部的对象锁，该锁被其它线程持有时，线程将进入阻塞状态。当其它线程释放该锁，且线程调度器允许线程持有该锁的时候，才会变为非阻塞状态。

4. Waiting(等待)
  >当线程等待另一个线程通知调度器一个条件时，他自己将进入等待状态。(调用Thread.sleep、Object.wait、Thread.join、Lock.tryLock以及Condition.await)

5. Timed waiting(计时等待)
  >当调用线程的几个方法的超时重载方法时，线程将进入计时等待状态(调用带超时参数的的Thread.sleep、Object.wait、Thread.join、Lock.tryLock以及Condition.await)

    **注：** 线程处于阻塞或者等待状态时，它将暂时不活动，不运行任何代码，且消耗最少的资源，直到线程调度器重新激活它。具体取决于它是怎样达到非活动状态。


6. Terminated(被终止)

  **注：** 调用stop方法可以杀死一个线程，该方法抛出一个ThreadDeath错误对象，但是该方法已经过时

  - run方法自然结束  
  - 因为一个没有捕获的异常终止run方法


### 线程属性
1. 优先级
  >t.setPriority(1-10)  
  线程优先级高度依赖于操作系统，尽量避免使用优先级。

2. 守护线程
  >t.setDaemon(true)。  
  唯一用途时为其他线程提供服务，守护线程应该永远不要访问固有资源，因为他会在任何时候发生中断。

3. 未捕获异常处理器
  >

4. 线程组

### 同步
  大多数实际多线程应用中，两个或者以上的线程需要共享同一数据的存取，这时容易产生**竞争条件**

1. 锁对象
  >ReentrantLock类

2. 条件对象
  >线程进入**临界区**之后发现，它需要满足某个**条件**才能做有用的工作。但这时它已经获取了排它性访问，因此其它线程没有访问权限。这时候就需要**条件对象**（或条件变量）。一个锁对象可以拥有多个条件对象，可以通过锁的newCondition获取。这时就可以通过在不满足条件的地方调用condition的await方法阻塞当前线程，让其他线程执行直到满足条件时调用signalAll(signal随机一个)方法让因为这一条件而等待的所有线程可以被激活。  
  **注：** 如果signal系列方法无法让等待的线程变成可激活状态，很可能造成死锁。

3. synchronized关键字
  >如果一个方法使用**synchronized**关键字修饰，那么**对象的锁**将保护这个方法。线程必须要获得对象的锁才能访问该方法。  
  用**synchronized**修饰静态方法，该方法将获得**类对象的内部锁**。这时只有当前线程可以访问这个类的所有静态方法。

4. 同步阻塞
  >

5. 监视器概念
  >一种不考虑如何加锁额情况下保证线程安全的解决方案。

6. volatile变量
  >

7. Final域

8. 原子性

9. 死锁

  >1.所有线程都被阻塞了。  
  2.线程满足条件对象的条件之后调用signal方法没有唤醒任何一个线程。

10. 线程局部变量
  >当我们需要避免共享变量的时候，可以使用ThreadLocal辅助类为各个线程提供各自的实例。

11. 锁测试与超时
  >一个线程调用lock方法来获得另一个线程所持有的锁时，很容易发生阻塞。

12. 读写锁

13. 弃用stop/suspend方法的原因
  >stop终结线程所有未结束的方法，包括run方法。当线程终止，立即释放被它锁住的所有对象的锁。这会导致对象处于不一致的状态。例如一个线程正在执行转账操作的时候被中止，钱已经被转出却没转到目标账户，这时中止线程对象就被破坏了（因为锁已经释放），其它线程会观察到。

### 阻塞队列

### 线程安全的集合
### Callable与Future
### 执行器
### 同步器
